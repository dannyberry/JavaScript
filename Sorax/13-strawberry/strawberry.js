/* Scope - область видимости переменной
Scope chain - цепочки областей видимости */

/* Переменные по области видимости делятся на глобальные и локальные.
Глобальные - все переменные, объявленные вне каких либо функций. */

var strawberry = 5;

/* p.s. При объявлении глобальной переменной можно не писать слово var.
НО МОЖНО != НЕ НУЖНО.

А вот при объявлении локальных переменных - должны. Ибо в ином случае
мы будем просто задавать значение переменной, которая находится в следующей
области видимости в цепочке, а не создавать локальную.*/

/* В языке JavaScript ТОЛЬКО функции создают локальную область видимости
в отличии, например, от языка C, где локальные области видимости создают 
любые блоки с фигурными скобками. */

/* Объявленные внутри функции являются локальными. 
Локальная переменная с таким же именем, как и глобальная имеет больший приоритет.
*/

var func = function() {
	var strawberry = 10;
	console.log(strawberry);
	var innerFunc =  function() {
		//var strawberry = 15;
		strawberry = 15;
		console.log(strawberry); 		/* Если переменной вообще не будет в этой области видимости
										цепочки, то покажется значение переменной, которая на цепочку выше*/
	};
	innerFunc();
	console.log(strawberry);
	console.log(""); 
};

func();

/* Когда мы обращаемся к переменной strawberry в функции innerFunc,
интерпретатор в первую очередь проверяет первую область видимости цепочки.
Т.е. саму функцию innerFunc. Если переменной в этой области ненаходится, 
переходит к следующей области видимости цепочки. */

/* ПОДЪЕМ ИЛИ HOISTING */


var hoisting = function() {
	var strawberry = 10;
	console.log(strawberry);
	var innerFunc =  function() {
		console.log(strawberry); // Что будет, если мы обратимся к переменной до её объяления. 
		var strawberry = 15;
	};
	innerFunc();
	console.log(strawberry);
};

/* В других языках вывелось значение переменной из предыдущей области видимости цепочки.
Но JavaScript заранее знает обо всех объявленных переменных внутри функции.
Поэтому выведется undefined. Потому что интерпритатор по сути поднимает все ОБЪЯВЛЕНИЯ переменных 
в начало функции. А инициализация остаётся на месте. Это будет аналогично следующему коду:

var hoisting = function() {
	var strawberry = 10;
	console.log(strawberry);
	var innerFunc =  function() {
		var strawberry;
		console.log(strawberry);
		strawberry = 15;
	};
	innerFunc();
	console.log(strawberry);
};

 */
hoisting();